#!/usr/bin/env bash
set -euo pipefail

# Resolve a LaTeX citation or BibTeX key to a Markdown fulltext file in ~/papers
# See --help for detailed usage.

PAPERS_DIR=${PAPERS_DIR:-"$HOME/papers"}
INDEX_FILE="$PAPERS_DIR/bibtex-index.jsonl"

print_help() {
  cat <<'EOF'
cite2md â€” resolve citation/key(s) to Markdown fulltext path(s)

Usage:
  cite2md [--cat] [citation-or-key ...]
  cite2md [--cat]               # read newline-delimited keys from stdin

Inputs accepted:
  - LaTeX-style citation, e.g. "\citet{vesper:2012_jumping}"
  - BibTeX key with colons, e.g. vesper:2012_jumping
  - Normalized key (colons removed), e.g. vesper2012_jumping

Output modes (default: path):
  - path (default): absolute file path to the Markdown fulltext (one per resolved key)
  - --cat: print the entire Markdown file(s) to stdout (concatenated)

Resolution strategy:
  1) Search $PAPERS_DIR for files ending with <normalized-key>.md
  2) Fallback to $PAPERS_DIR/bibtex-index.jsonl, matching .key (with colons)
     or normalized .key (colons removed), using .path or .filename

Environment:
  - PAPERS_DIR: override papers root (default: $HOME/papers)

Exit codes:
  - 0: success
  - 1: not found
  - 2: usage error / missing input

Dependencies:
  - fd, jq, sed, awk

Examples:
  cite2md "\citet{vesper:2012_jumping}"
  cite2md --cat vesper:2012_jumping | sed -n '1,5p'
  printf '%s\n' vesper:2012_jumping butterfill:2019_goals | cite2md --cat
  rg -n "joint outcome" "$(cite2md vesper2012_jumping)"
EOF
}

if [ $# -lt 1 ]; then
  # no args: may be stdin mode or help
  if [ -t 0 ]; then
    print_help >&2
    exit 2
  fi
fi

# Parse flags
MODE="path" # default: print file path
while [[ $# -gt 0 ]]; do
  case "$1" in
    --cat)
      MODE="cat"; shift ;;
    -h|--help)
      print_help; exit 0 ;;
    --)
      shift; break ;;
    -*)
      echo "Unknown flag: $1" >&2; exit 2 ;;
    *)
      break ;;
  esac
done

# Collect inputs: remaining args or stdin if none
declare -a INPUTS
if [[ $# -gt 0 ]]; then
  while [[ $# -gt 0 ]]; do
    INPUTS+=("$1"); shift
  done
else
  while IFS= read -r line; do
    [[ -z "$line" ]] && continue
    [[ "$line" =~ ^[[:space:]]*# ]] && continue
    INPUTS+=("$line")
  done
fi

if [[ ${#INPUTS[@]} -eq 0 ]]; then
  echo "cite2md: no input keys provided" >&2
  exit 2
fi

resolved_any=false
missing_log_file="missing-keys.txt"

resolve_one() {
  local input="$1"; local bibkey normkey file rel
  # Extract bibkey if LaTeX citation; otherwise use input as key
  if [[ "$input" =~ \{[^}]+\} ]]; then
    bibkey=$(printf '%s\n' "$input" | sed -n 's/.*{\([^}]*\)}.*/\1/p')
  else
    bibkey="$input"
  fi
  if [ -z "$bibkey" ]; then
    echo "cite2md: could not parse a key from input: $input" >&2
    return 1
  fi
  normkey=$(printf '%s' "$bibkey" | tr -d ':')
  file=$(fd -a -t f --regex "${normkey}\\.md$" "$PAPERS_DIR" | head -n1 || true)
  if [ -z "$file" ] && [ -f "$INDEX_FILE" ]; then
    rel=$(jq -r --arg k "$bibkey" 'select(.key==$k) | .path // .filename' "$INDEX_FILE" 2>/dev/null || true)
    if [ -z "${rel:-}" ] || [ "$rel" = "null" ]; then
      rel=$(jq -r --arg nk "$normkey" 'select((.key|gsub(":";""))==$nk) | .path // .filename' "$INDEX_FILE" 2>/dev/null || true)
    fi
    if [ -n "${rel:-}" ] && [ "$rel" != "null" ]; then
      file="$PAPERS_DIR/$rel"
    fi
  fi
  if [ -z "$file" ] || [ ! -f "$file" ]; then
    echo "MISSING cite2md: $bibkey (normalized: $normkey) in $PAPERS_DIR" >&2
    printf '%s\n' "$bibkey" >> "$missing_log_file"
    return 1
  fi
  case "$MODE" in
    path)
      printf '%s\n' "$file" ;;
    cat)
      cat "$file" ;;
  esac
  return 0
}

rc_overall=1
for token in "${INPUTS[@]}"; do
  if resolve_one "$token"; then
    resolved_any=true
  fi
done

if $resolved_any; then rc_overall=0; fi
exit $rc_overall
