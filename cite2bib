#!/usr/bin/env bash
set -euo pipefail

# Resolve a LaTeX citation or BibTeX key to its BibTeX entry
# See --help for detailed usage.

BIB_FILE=${BIB_FILE:-"$HOME/endnote/phd_biblio.bib"}

print_core_help() {
  cat <<'EOF'
cite2bib — resolve citation/key to BibTeX entry

Usage:
  cite2bib <citation-or-key>

Behavior:
  - Prints the matching BibTeX entry to stdout
  - Exit codes: 0 success, 1 not found, 2 usage error

Examples (list → then read one):
  find-bib --author vesper --year 2013 --title jump > keys.txt
  key=$(sed -n '1p' keys.txt)
  cite2bib "$key" | rg '^@'
  cite2bib vesper2012_jumping > vesper.bib
EOF
}

print_human_help() {
  print_core_help
  cat <<EOF

Inputs:
  - LaTeX-style citation (e.g. \\citet{vesper:2012_jumping})
  - BibTeX key with colons (e.g. vesper:2012_jumping)
  - Normalized key without colons (e.g. vesper2012_jumping)

Environment:
  - BIB_FILE (default: ${BIB_FILE})
  - missing-keys.txt is appended in the working directory on misses

Resolution strategy:
  - ripgrep for exact key matches (^@type{key,)
  - fallback: strip colons and scan for normalized key with awk/gawk

Dependencies:
  - rg, awk (or gawk), sed

Workflow tips:
  - Combine with find-bib to shortlist keys before fetching entries.
  - Use cite2bib <key> | rg '^@' to confirm the key resolves.

Examples (list → then read one):
  find-bib --author vesper --year 2013 --title jump > keys.txt
  key=$(sed -n '1p' keys.txt)
  cite2bib "$key" | rg '^@'
  cite2bib vesper2012_jumping > vesper.bib
EOF
}

human_requested=false
help_requested=false
for arg in "$@"; do
  case "$arg" in
    --human) human_requested=true ;;
    -h|--help) help_requested=true ;;
  esac
done

if $human_requested; then
  for arg in "$@"; do
    case "$arg" in
      --human|-h|--help) ;;
      *)
        echo "cite2bib: --human cannot be combined with $arg" >&2
        exit 2
        ;;
    esac
  done
  print_human_help
  exit 0
fi

if $help_requested; then
  print_core_help
  exit 0
fi

if [ $# -lt 1 ]; then
  print_core_help >&2
  exit 2
fi

input="$1"

# Extract bibkey if LaTeX citation; otherwise use input as key
if [[ "$input" =~ \{[^}]+\} ]]; then
  bibkey=$(printf '%s\n' "$input" | sed -n 's/.*{\([^}]*\)}.*/\1/p')
else
  bibkey="$input"
fi

if [ -z "$bibkey" ]; then
  echo "Could not parse a key from input: $input" >&2
  exit 2
fi

normkey=$(printf '%s' "$bibkey" | tr -d ':')

if [ ! -f "$BIB_FILE" ]; then
  echo "BibTeX file not found: $BIB_FILE" >&2
  exit 1
fi

# Function: print the entry starting at a line number
extract_from_line() {
  local start_line="$1"
  awk -v start="$start_line" 'NR<start{next} { if (!started) started=1; line=$0; opens=gsub(/\{/ ,"{", line); closes=gsub(/\}/ ,"}", line); depth+=opens-closes; print; if (started && depth<=0) exit }' "$BIB_FILE"
}

# Try exact key match first
start_line=$(rg -n "^[[:space:]]*@[A-Za-z]+\{${bibkey}," "$BIB_FILE" | head -n1 | cut -d: -f1 || true)

if [ -n "${start_line:-}" ]; then
  extract_from_line "$start_line"
  exit 0
fi

# Fallback: match on normalized key (colons removed)
# Prefer gawk for speed (capture array in match), else POSIX awk path.
# Allow override via CITE2BIB_AWK_IMPL=awk|gawk for testing.
awk_impl=${CITE2BIB_AWK_IMPL:-}
if [ "$awk_impl" = "gawk" ]; then
  : # force gawk path below
elif [ "$awk_impl" = "awk" ]; then
  : # force awk path below
elif command -v gawk >/dev/null 2>&1; then
  awk_impl="gawk"
else
  awk_impl="awk"
fi

if [ "$awk_impl" = "gawk" ]; then
  start_line=$(gawk -v nk="$normkey" '
    match($0, /^[[:space:]]*@[A-Za-z]+\{([^,]+),/, m) {
      key=m[1]; gsub(":","",key);
      if (key==nk) { print NR; exit }
    }
  ' "$BIB_FILE")
else # POSIX awk
  start_line=$(awk -v nk="$normkey" '
    # Portable POSIX AWK: avoid capture arrays
    $0 ~ /^[[:space:]]*@[A-Za-z]+\{/ {
      line = $0
      # Strip prefix up to the first "{"
      sub(/^[[:space:]]*@[A-Za-z]+\{/, "", line)
      # Key is up to the first comma
      key = line
      sub(/,.*/, "", key)
      gsub(":", "", key)
      if (key == nk) { print NR; exit }
    }
  ' "$BIB_FILE")
fi

if [ -n "${start_line:-}" ]; then
  extract_from_line "$start_line"
  exit 0
fi

# Not found: standardized stderr and log to ./missing-keys.txt
echo "MISSING cite2bib: $bibkey (normalized: $normkey) in $BIB_FILE" >&2
printf '%s\n' "$bibkey" >> "missing-keys.txt"
exit 1
