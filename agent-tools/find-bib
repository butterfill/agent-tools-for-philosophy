#!/usr/bin/env python3
import os
import sys
import argparse

DEFAULT_BIB = os.path.expanduser(os.environ.get("BIB_FILE", "${HOME}/endnote/phd_biblio.bib").replace("${HOME}", os.path.expanduser("~")))

HELP_TEXT = """find-bib â€” search entries in a BibTeX file

Usage:
  find-bib [--author TXT] [--year YYYY] [--doi TXT] [--title TXT] [--abstract TXT] [--cat] [--limit N]

Filters (repeatable; case-insensitive substring):
  --author TXT     Match author field
  --year YYYY      Match year field (string compare)
  --doi TXT        Match doi field
  --title TXT      Match title field
  --abstract TXT   Match abstract field

Output:
  - default: print matching keys (one per line)
  - --cat: print full BibTeX entries

Environment:
  - BIB_FILE: path to BibTeX file (default: $HOME/endnote/phd_biblio.bib)

Exit codes:
  0: success (printed at least one result)
  1: no matches
  2: usage/config/dependency error
"""

def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

def parse_args(argv):
    p = argparse.ArgumentParser(add_help=False)
    p.add_argument("-h", "--help", action="store_true")
    p.add_argument("--author", action="append", default=[])
    p.add_argument("--year", action="append", default=[])
    p.add_argument("--doi", action="append", default=[])
    p.add_argument("--title", action="append", default=[])
    p.add_argument("--abstract", action="append", default=[])
    p.add_argument("--cat", action="store_true")
    p.add_argument("--limit", type=int, default=0)
    return p.parse_args(argv)

def norm(s: str) -> str:
    # Lowercase, collapse whitespace, remove braces commonly used in BibTeX titles
    return " ".join(s.replace("{", "").replace("}", "").lower().split())

def load_bib(path: str):
    try:
        import bibtexparser  # type: ignore
        from bibtexparser.bwriter import BibTexWriter  # noqa: F401
        from bibtexparser.bibdatabase import BibDatabase  # noqa: F401
    except Exception:
        eprint("find-bib: missing Python dependency: bibtexparser (pip install bibtexparser)")
        sys.exit(2)

    if not os.path.isfile(path):
        eprint(f"find-bib: BibTeX file not found: {path}")
        sys.exit(2)

    with open(path, "r", encoding="utf-8") as f:
        try:
            db = bibtexparser.load(f)
        except Exception as ex:
            eprint(f"find-bib: failed to parse BibTeX file: {ex}")
            sys.exit(2)
    return db

def entry_field(entry: dict, field: str) -> str:
    val = entry.get(field)
    if not val:
        return ""
    # Some fields could be lists (depending on parser customization); coerce to str
    if isinstance(val, (list, tuple)):
        val = "; ".join(str(x) for x in val)
    return str(val)

def matches(entry: dict, filters: dict) -> bool:
    # AND across fields; OR within the list of values for the same field
    for field, values in filters.items():
        if not values:
            continue
        hay = norm(entry_field(entry, field))
        if not hay:
            return False
        ok = False
        for needle in values:
            if norm(needle) in hay:
                ok = True
                break
        if not ok:
            return False
    return True

def print_entries(entries):
    # Serialize entries back to BibTeX
    from bibtexparser.bwriter import BibTexWriter
    from bibtexparser.bibdatabase import BibDatabase

    writer = BibTexWriter()
    # Compact: do not align or sort unless needed
    writer.indent = "  "
    writer.order_entries_by = None

    db = BibDatabase()
    db.entries = entries
    out = writer.write(db)
    # Ensure trailing newline
    if not out.endswith("\n"):
        out += "\n"
    sys.stdout.write(out)

def main(argv):
    args = parse_args(argv)
    if args.help:
        sys.stdout.write(HELP_TEXT)
        return 0

    bib_path = DEFAULT_BIB
    db = load_bib(bib_path)

    filters = {
        "author": args.author,
        "year": args.year,
        "doi": args.doi,
        "title": args.title,
        "abstract": args.abstract,
    }

    matched = []
    for entry in db.entries:
        if matches(entry, filters):
            matched.append(entry)
            if args.limit and len(matched) >= args.limit:
                break

    if not matched:
        return 1

    if args.cat:
        print_entries(matched)
    else:
        for e in matched:
            key = e.get("ID", "")
            if key:
                print(key)
    return 0

if __name__ == "__main__":
    try:
        rc = main(sys.argv[1:])
    except KeyboardInterrupt:
        rc = 130
    sys.exit(rc)

