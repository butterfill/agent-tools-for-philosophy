#!/usr/bin/env bash
set -euo pipefail

# find-bib — filter CSL-JSON (Pandoc) bibliography by fields and emit keys, JSON, or BibTeX via cite2bib

BIB_JSON=${BIB_JSON:-"$HOME/endnote/phd_biblio.json"}

print_core_help() {
  cat <<'EOF'
find-bib — search entries in Pandoc CSL-JSON

Usage:
  find-bib [filters...] [--cat]

Filters (repeatable; case-insensitive substrings):
  --author TXT
  --year YYYY
  --doi TXT
  --title TXT
  --abstract TXT

Output:
  - default: print matching keys (one per line)
  - --cat: print each match as BibTeX via cite2bib

Exit codes: 0 success, 1 no matches, 2 usage/config error

Examples (list → then read one):
  find-bib --author vesper --year 2013 --title jump > keys.txt
  key=$(sed -n '1p' keys.txt)
  cite2bib "$key"
  # Or: p=$(cite2md "$key")
EOF
}

print_human_help() {
  print_core_help
  cat <<EOF

Environment:
  - BIB_JSON (default: ${BIB_JSON})
  - BIB_FILE (used by cite2bib when --cat is active)

Dependencies:
  - jq, cite2bib (required when using --cat)

Resolution details:
  - Normalizes author names and abstracts for substring search.
  - Derives year from CSL date-parts or literal strings.

Workflow tips:
  - Pipe into cite2md or cite2pdf after narrowing results to a small list.
  - Use --cat to validate keys against your BibTeX library before exporting.

Examples (list → then read one):
  find-bib --author vesper --year 2013 --title jump > keys.txt
  key=$(sed -n '1p' keys.txt)
  cite2bib "$key"
  # Or: p=$(cite2md "$key")
EOF
}

human_requested=false
help_requested=false
for arg in "$@"; do
  case "$arg" in
    --human) human_requested=true ;;
    -h|--help) help_requested=true ;;
  esac
done

if $human_requested; then
  for arg in "$@"; do
    case "$arg" in
      --human|-h|--help) ;;
      *)
        echo "find-bib: --human cannot be combined with $arg" >&2
        exit 2
        ;;
    esac
  done
  print_human_help
  exit 0
fi

if $help_requested; then
  print_core_help
  exit 0
fi

command -v jq >/dev/null 2>&1 || { echo "find-bib: jq not found on PATH" >&2; exit 2; }

if [[ ! -f "$BIB_JSON" ]]; then
  echo "find-bib: CSL-JSON file not found: $BIB_JSON" >&2
  exit 2
fi

authors=(); years=(); dois=(); titles=(); abstracts=()
mode="keys"

while [[ $# -gt 0 ]]; do
  case "$1" in
    --author) shift; authors+=("${1:-}"); shift || true ;;
    --year) shift; years+=("${1:-}"); shift || true ;;
    --doi) shift; dois+=("${1:-}"); shift || true ;;
    --title) shift; titles+=("${1:-}"); shift || true ;;
    --abstract) shift; abstracts+=("${1:-}"); shift || true ;;
    --cat) mode="cat"; shift ;;
    -*) echo "find-bib: unknown flag: $1" >&2; exit 2 ;;
    *) echo "find-bib: unexpected positional argument: $1" >&2; exit 2 ;;
  esac
done

# Build jq arrays
to_json_array() { # prints a JSON array from bash args, properly escaped via jq -R
  if [[ $# -eq 0 ]]; then echo '[]'; else printf '%s\n' "$@" | jq -Rsc 'split("\n")[:-1]'; fi
}

authors_json=$(to_json_array "${authors[@]:-}")
years_json=$(to_json_array "${years[@]:-}")
dois_json=$(to_json_array "${dois[@]:-}")
titles_json=$(to_json_array "${titles[@]:-}")
abstracts_json=$(to_json_array "${abstracts[@]:-}")

jq_prog='
def norm($s): ($s|tostring|gsub("[{}]";"")|ascii_downcase|gsub("\\s+";" ")|gsub("^\\s+|\\s+$";""));
def name_text($n): if ($n|type)=="object" then [ $n.family, $n.given ] | map(select(.!=null and .!="")) | join(", ") elif ($n|type)=="string" then $n else ($n|tostring) end;
def authors_text: if .author then ( if (.author|type)=="array" then (.author | map(name_text(.)) | join("; ")) else (.author|tostring) end ) elif .authors then (.authors|tostring) else "" end;
def year_text: if .issued and ((.issued["date-parts"]|type)=="array") and ((.issued["date-parts"][0]|type)=="array") and (.issued["date-parts"][0][0]) then (.issued["date-parts"][0][0]|tostring) elif .issued and (.issued.literal?) then (.issued.literal|tostring|capture("(?<y>(19|20)[0-9]{2})").y) elif .issued then (.issued|tostring|capture("(?<y>(19|20)[0-9]{2})").y) else "" end;
def key_of: .id // .ID // .key;
def get_items: if (type)=="array" then . else (.items // .records // []) end;
def match_any($hay; $needles): ($needles|length)==0 or ( [ $needles[] | norm(.) ] | any( . as $n | (norm($hay) | contains($n)) ) );
get_items
| map(select( (authors_text as $a | match_any($a; $authors))
             and (year_text as $y | match_any($y; $years))
             and ((.DOI // .doi // "") as $d | match_any($d; $dois))
             and ((.title // "") as $t | match_any($t; $titles))
             and ((.abstract // "") as $ab | match_any($ab; $abstracts)) ))
| .[]
'

out=""
case "$mode" in
  keys)
    out=$(jq -r \
      --argjson authors "$authors_json" \
      --argjson years "$years_json" \
      --argjson dois "$dois_json" \
      --argjson titles "$titles_json" \
      --argjson abstracts "$abstracts_json" \
      "$jq_prog | key_of" "$BIB_JSON")
    ;;
  cat)
    command -v cite2bib >/dev/null 2>&1 || { echo "find-bib: cite2bib not found for --cat" >&2; exit 2; }
    keys=$(jq -r \
      --argjson authors "$authors_json" \
      --argjson years "$years_json" \
      --argjson dois "$dois_json" \
      --argjson titles "$titles_json" \
      --argjson abstracts "$abstracts_json" \
      "$jq_prog | key_of" "$BIB_JSON")
    if [[ -n "$keys" ]]; then
      while IFS= read -r k; do
        [[ -z "$k" ]] && continue
        cite2bib "$k" || true
      done <<< "$keys"
    fi
    ;;
esac

if [[ "$mode" != "cat" ]]; then
  out=$(printf '%s\n' "$out" | sed '/^\s*$/d')
  if [[ -n "$out" ]]; then
    printf '%s\n' "$out"
    exit 0
  else
    exit 1
  fi
else
  # cat mode: decide success by whether anything matched
  if jq -e \
      --argjson authors "$authors_json" \
      --argjson years "$years_json" \
      --argjson dois "$dois_json" \
      --argjson titles "$titles_json" \
      --argjson abstracts "$abstracts_json" \
      "$jq_prog | key_of | length > 0" "$BIB_JSON" >/dev/null; then
    exit 0
  else
    exit 1
  fi
fi
