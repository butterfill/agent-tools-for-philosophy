#!/usr/bin/env bash
set -euo pipefail

# find-bib.sh — case-insensitive BibTeX key finder with simple field filters

BIB_FILE=${BIB_FILE:-"$HOME/endnote/phd_biblio.bib"}
PAPERS_DIR=${PAPERS_DIR:-"$HOME/papers"}
INDEX_FILE="$PAPERS_DIR/bibtex-index.jsonl"

print_help() {
  cat <<'EOH'
find-bib.sh — find BibTeX keys by field filters or source search

Usage:
  find-bib.sh [filters...] [--sources "query"] [--with-md|--cat] [--limit N] [free-text]

Filters (repeatable, case-insensitive substrings):
  --author NAME   --year YYYY   --doi DOI   --title TEXT   --abstract TEXT

Source-assisted:
  --sources QUERY   Search Markdown in $PAPERS_DIR using rg-sources, then map to keys.

Output (default: keys-only, one per line):
  --with-md   Append Markdown path if available (key<TAB>path)
  --cat       Print full BibTeX entries instead of keys
  --limit N   Limit number of results (default 50)

Scope:
  --bib PATH      Override BibTeX file (default: $HOME/endnote/phd_biblio.bib)
  --papers PATH   Override papers dir (default: $HOME/papers)

Free-text:
  If no field filters are given, a positional free-text string (or stdin) is parsed
  to infer simple filters (author surname, 4-digit year, and probable title phrase).

Exit codes: 0 success; 1 no matches; 2 usage/config error
Dependencies: rg, awk, sed; jq & rg-sources for --with-md / --sources
EOH
}

if [[ ${1:-} == "-h" || ${1:-} == "--help" ]]; then
  print_help
  exit 0
fi

authors=(); years=(); dois=(); titles=(); abstracts=()
with_md=false; cat_mode=false; limit=50; sources_query=""
free_text=""

# Capture stdin if piped
stdin_buf=""
if [ ! -t 0 ]; then
  stdin_buf=$(cat || true)
fi

# Parse args
while [[ $# -gt 0 ]]; do
  case "$1" in
    --author) shift; authors+=("${1:-}"); shift || true ;;
    --year) shift; years+=("${1:-}"); shift || true ;;
    --doi) shift; dois+=("${1:-}"); shift || true ;;
    --title) shift; titles+=("${1:-}"); shift || true ;;
    --abstract) shift; abstracts+=("${1:-}"); shift || true ;;
    --sources) shift; sources_query="${1:-}"; shift || true ;;
    --with-md) with_md=true; shift ;;
    --cat) cat_mode=true; shift ;;
    --limit) shift; limit=${1:-50}; shift || true ;;
    --bib) shift; BIB_FILE="${1:-}"; shift || true ;;
    --papers) shift; PAPERS_DIR="${1:-}"; INDEX_FILE="$PAPERS_DIR/bibtex-index.jsonl"; shift || true ;;
    --) shift; break ;;
    -*) echo "Unknown flag: $1" >&2; exit 2 ;;
    *) free_text="$1"; shift ;;
  esac
done

if [[ ! -f "$BIB_FILE" ]]; then
  echo "find-bib.sh: BibTeX file not found: $BIB_FILE" >&2
  exit 2
fi

# Infer filters from free-text if none provided
if [[ ${#authors[@]} -eq 0 && ${#years[@]} -eq 0 && ${#dois[@]} -eq 0 && ${#titles[@]} -eq 0 && ${#abstracts[@]} -eq 0 ]]; then
  if [[ -z "$free_text" && -n "$stdin_buf" ]]; then
    free_text="$stdin_buf"
  fi
  if [[ -n "$free_text" ]]; then
    a=$(printf '%s' "$free_text" | sed -n 's/^\s*\([^,]\+\),.*/\1/p' | awk '{print $1}' | tr '[:upper:]' '[:lower:]' || true)
    [[ -n "$a" ]] && authors+=("$a")
    y=$(printf '%s' "$free_text" | rg -io "\b(19|20)\d{2}\b" -m1 || true)
    [[ -n "$y" ]] && years+=("$y")
    t=$(printf '%s' "$free_text" | sed -n 's/.*)\.\s*\([^\.][^\.]*\)\..*/\1/p' | tr '[:upper:]' '[:lower:]' || true)
    if [[ -n "$t" ]]; then
      titles+=("$t")
    else
      t=$(printf '%s' "$free_text" | sed -n 's/.*\([A-Z][A-Za-z]\+\( [A-Z][A-Za-z]\+\)\{1,4\}\).*/\1/p' | head -n1 | tr '[:upper:]' '[:lower:]' || true)
      [[ -n "$t" ]] && titles+=("$t")
    fi
  fi
fi

# AWK-based filter over BibTeX
awk_filter_bib() {
  local mode="$1" # keys|cat
  local limit="$2"
  local a_join="$3"; local y_join="$4"; local d_join="$5"; local t_join="$6"; local ab_join="$7"
  awk -v a_join="$a_join" -v y_join="$y_join" -v d_join="$d_join" -v t_join="$t_join" -v ab_join="$ab_join" -v mode="$mode" -v limit="$limit" '
    function tolower_str(s){
      for(i=1;i<=length(s);i++){c=substr(s,i,1); out=out tolower(c)}; t=out; out=""; return t
    }
    function contains(hay,needle){return (needle=="" || index(hay, needle)>0)}
    BEGIN{
      split(a_join, A, "\t"); split(y_join, Y, "\t"); split(d_join, D, "\t"); split(t_join, T, "\t"); split(ab_join, AB, "\t");
      want=limit+0
    }
    /^\s*@[A-Za-z]+\{[^,]+,/ { entry=""; depth=0; have=1; if (match($0,/^\s*@[A-Za-z]+\{([^,]+),/,m)) key=m[1]; else key="" }
    { if (have){ line=$0; o=gsub(/\{/ ,"{", line); c=gsub(/\}/ ,"}", line); depth+=o-c; entry=entry $0 "\n"; if (depth<=0){ lower=tolower_str(entry); gsub(/[{}]/,"",lower);
        ok=1; for(i in A){ if(A[i]!="" && !contains(lower,A[i])){ok=0;break} } if(!ok){entry="";next}
        for(i in Y){ if(Y[i]!="" && !contains(lower,Y[i])){ok=0;break} } if(!ok){entry="";next}
        for(i in D){ if(D[i]!="" && !contains(lower,D[i])){ok=0;break} } if(!ok){entry="";next}
        for(i in T){ if(T[i]!="" && !contains(lower,T[i])){ok=0;break} } if(!ok){entry="";next}
        for(i in AB){ if(AB[i]!="" && !contains(lower,AB[i])){ok=0;break} } if(ok){ if(mode=="cat"){print entry}else{print key} found++; if(found>=want && want>0) exit } entry="" } } }
  ' "$BIB_FILE"
}

join_tab_lower() { for s in "$@"; do printf '%s\t' "$(printf '%s' "$s" | tr '[:upper:]' '[:lower:]')"; done; }

keys_from_bib() {
  local mode="$1"
  awk_filter_bib "$mode" "$limit" "$(join_tab_lower "${authors[@]:-}")" "$(join_tab_lower "${years[@]:-}")" "$(join_tab_lower "${dois[@]:-}")" "$(join_tab_lower "${titles[@]:-}")" "$(join_tab_lower "${abstracts[@]:-}")" | sed '/^\s*$/d'
}

keys_from_sources() {
  local q="$1"
  [[ -z "$q" ]] && return 0
  command -v rg-sources >/dev/null 2>&1 || { echo "find-bib.sh: rg-sources not found but --sources used" >&2; exit 2; }
  [[ -f "$INDEX_FILE" ]] || { echo "find-bib.sh: index file not found: $INDEX_FILE" >&2; exit 2; }
  local tmp
  tmp=$(mktemp)
  (
    cd "$PAPERS_DIR"
    rg-sources -l -i "$q" | while IFS= read -r p; do basename -- "$p"; done | sed '/^$/d' | sort -u > "$tmp"
  )
  while IFS= read -r name; do jq -r --arg n "$name" 'select(.filename==$n) | .key' "$INDEX_FILE"; done < "$tmp" | sort -u
  rm -f "$tmp"
}

bib_mode="keys"; [[ "$cat_mode" == true ]] && bib_mode="cat"

keys1=$(keys_from_bib "$bib_mode" || true)
keys2=""
if [[ -n "$sources_query" ]]; then keys2=$(keys_from_sources "$sources_query" || true); fi

combine_keys() {
  local a="$1" b="$2"
  if [[ -n "$b" ]]; then
    if [[ -n "$a" ]]; then
      comm -12 <(printf '%s\n' "$a" | sort -u) <(printf '%s\n' "$b" | sort -u)
    else
      printf '%s\n' "$b"
    fi
  else
    printf '%s\n' "$a"
  fi
}

result_keys=$(combine_keys "$keys1" "$keys2" | head -n "$limit")

# If free-text was used and nothing found, relax title filter and retry once
if [[ -z "$result_keys" && -n "$free_text" ]]; then
  titles=()
  keys1=$(keys_from_bib "keys" || true)
  result_keys=$(combine_keys "$keys1" "$keys2" | head -n "$limit")
fi

[[ -z "$result_keys" ]] && exit 1

if $cat_mode; then
  # Print full entries for result_keys
  while IFS= read -r key; do
    [[ -z "$key" ]] && continue
    start_line=$(rg -n "^\s*@\w+\{${key}," "$BIB_FILE" | head -n1 | cut -d: -f1 || true)
    if [[ -n "$start_line" ]]; then
      awk -v start="$start_line" 'NR<start{next} { if (!started) started=1; line=$0; o=gsub(/\{/ ,"{", line); c=gsub(/\}/ ,"}", line); d+=o-c; print; if (started && d<=0) exit }' "$BIB_FILE"
    fi
  done <<< "$result_keys"
else
  if $with_md; then
    command -v jq >/dev/null 2>&1 || { echo "find-bib.sh: jq required for --with-md" >&2; exit 2; }
    while IFS= read -r k; do
      [[ -z "$k" ]] && continue
      md=$(jq -r --arg k "$k" 'select(.key==$k) | .filename // .path // empty' "$INDEX_FILE" | head -n1 || true)
      if [[ -n "$md" ]]; then printf '%s\t%s/%s\n' "$k" "$PAPERS_DIR" "$md"; else printf '%s\n' "$k"; fi
    done <<< "$result_keys"
  else
    printf '%s\n' "$result_keys"
  fi
fi
